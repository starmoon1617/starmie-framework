/*
 * Copyright (c) 2023, Starmoon1617 and/or Nathan Liao. All rights reserved.
 *
 */
package io.github.starmoon1617.starmie.generator.core.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import org.mybatis.generator.api.IntrospectedColumn;
import org.mybatis.generator.api.IntrospectedTable;
import org.mybatis.generator.internal.util.StringUtility;

import io.github.starmoon1617.starmie.generator.core.constant.Constants;

/**
 * Utility Class for Comments, Comments are multi-line Comments
 * 
 * @date 2023-10-16
 * @author Nathan Liao
 */
public class CommentsUtils {

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(Constants.DATE_FORMAT);

    private CommentsUtils() {

    }

    /**
     * format current time to 'yyyy-MM-dd' string
     * 
     * @return
     */
    public static final String getCurrentDate() {
        return LocalDateTime.now().format(DATE_FORMATTER);
    }

    /**
     * default comment for a file
     * 
     * @return
     */
    public static String getFileComment() {
        StringBuilder sb = new StringBuilder("/*\n");
        sb.append(" * Copyright (c) ").append(Calendar.getInstance().get(Calendar.YEAR)).append(", Starmoon1617 and/or Nathan Liao. All rights reserved.\n");
        sb.append(" */");
        return sb.toString();
    }

    /**
     * default comment for a Class
     * 
     * @return
     */
    public static String getTypeComment(String comment) {
        StringBuilder sb = new StringBuilder("/**\n");
        sb.append(" * ");
        if (StringUtility.stringHasValue(comment)) {
            sb.append(comment);
        }
        sb.append("\n");
        sb.append(" *\n");
        sb.append(" * Generated by Starmie Generator.\n");
        sb.append(" *\n");
        sb.append(" * @date ");
        sb.append(getCurrentDate());
        sb.append("\n");
        sb.append(" */");
        return sb.toString();
    }

    /**
     * return comment for model class
     * 
     * @return
     */
    public static String getModelComment(IntrospectedTable introspectedTable) {
        StringBuilder sb = new StringBuilder("/**\n");
        String remarks = introspectedTable.getRemarks();
        if (StringUtility.stringHasValue(remarks)) {
            String[] remarkLines = remarks.split(System.getProperty("line.separator"));
            for (String remarkLine : remarkLines) {
                sb.append(" *   ");
                sb.append(remarkLine);
                sb.append("\n");
            }
            sb.append(" *\n");
        }
        sb.append(" * Generated by Starmie Generator, corresponds to the database table ");
        sb.append(introspectedTable.getFullyQualifiedTableNameAtRuntime());
        sb.append("\n");
        sb.append(" *\n");
        sb.append(" * @date ");
        sb.append(getCurrentDate());
        sb.append("\n");
        sb.append(" */");
        return sb.toString();
    }

    /**
     * return field comment for a model
     * 
     * @param introspectedTable
     * @param introspectedColumn
     * @return
     */
    public static List<String> getFieldComment(IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {
        List<String> comments = new ArrayList<>();
        comments.add("/**");

        StringBuilder sb = new StringBuilder(" * ");
        sb.append(introspectedTable.getFullyQualifiedTableNameAtRuntime());
        sb.append(Constants.DOT);
        sb.append(introspectedColumn.getActualColumnName());
        String remarks = introspectedColumn.getRemarks();
        if (StringUtility.stringHasValue(remarks)) {
            String[] remarkLines = remarks.split(System.getProperty("line.separator"));
            for (String remarkLine : remarkLines) {
                sb.append(" ").append(Constants.HYPHEN).append(" ").append(remarkLine);
            }
        }
        comments.add(sb.toString());
        comments.add(" *");
        comments.add(" * Generated by Starmie Generator.");
        comments.add(" */");

        return comments;
    }

    /**
     * return Getter method comment for a model
     * 
     * @param introspectedTable
     * @param introspectedColumn
     * @return
     */
    public static List<String> getGetterComment(IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {
        List<String> comments = new ArrayList<>();
        comments.add("/**");
        comments.add(" * This method was generated by Starmie Generator.");

        StringBuilder sb = new StringBuilder(" * This method returns the value of the database column ");
        sb.append(introspectedTable.getFullyQualifiedTableNameAtRuntime());
        sb.append(Constants.DOT);
        sb.append(introspectedColumn.getActualColumnName());
        String remarks = introspectedColumn.getRemarks();
        if (StringUtility.stringHasValue(remarks)) {
            String[] remarkLines = remarks.split(System.getProperty("line.separator"));
            for (String remarkLine : remarkLines) {
                sb.append(" ").append(Constants.HYPHEN).append(" ").append(remarkLine);
            }
        }
        comments.add(sb.toString());

        sb.setLength(0);
        sb.append(" * @return the value of ");
        sb.append(introspectedTable.getFullyQualifiedTable()).append('.').append(introspectedColumn.getActualColumnName());
        comments.add(sb.toString());

        comments.add(" */");
        return comments;
    }

    /**
     * return Setter method comment for a model
     * 
     * @param introspectedTable
     * @param introspectedColumn
     * @return
     */
    public static List<String> getSetterComment(IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {
        
        List<String> comments = new ArrayList<>();
        comments.add("/**");
        comments.add(" * This method was generated by Starmie Generator.");
        
        StringBuilder sb = new StringBuilder(" * This method sets the value of the database column ");
        sb.append(introspectedTable.getFullyQualifiedTableNameAtRuntime());
        sb.append('.');
        sb.append(introspectedColumn.getActualColumnName());
        String remarks = introspectedColumn.getRemarks();
        if (StringUtility.stringHasValue(remarks)) {
            String[] remarkLines = remarks.split(System.getProperty("line.separator"));
            for (String remarkLine : remarkLines) {
                sb.append(" ").append(Constants.HYPHEN).append(" ").append(remarkLine);
            }
        }
        comments.add(sb.toString());

        sb.setLength(0);
        sb.append(" * @param ");
        sb.append(introspectedColumn.getJavaProperty()).append(" the value for ").append(introspectedTable.getFullyQualifiedTable());
        sb.append(Constants.DOT).append(introspectedColumn.getActualColumnName());
        comments.add(sb.toString());

        comments.add(" */");
        return comments;
    }

}
